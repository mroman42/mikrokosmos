<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-08-29 Tue 19:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mikrokosmos</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mario Román [[https://github.com/M42/][(github)]](github)" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/codemirror.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/addon/mode/simple.min.js"></script>
<script src="https://m42.github.io/mikrokosmos-js/codemirrormkr.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/rts.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/lib.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/out.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/runmain.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/mikrobox.js" defer></script>
<link rel="stylesheet" href="styles/mikrocode.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Mikrokosmos
<br>
<span class="subtitle">Programming on the λ-calculus</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org5f13c2a">1. The &lambda;-calculus</a>
<ul>
<li><a href="#org5bb9158">1.1. The &lambda;-calculus</a></li>
<li><a href="#org5aa7bc0">1.2. A first example</a></li>
<li><a href="#org41d52eb">1.3. Some more examples</a></li>
<li><a href="#org6d6ed4d">1.4. An exercise</a></li>
</ul>
</li>
<li><a href="#org8dc0986">2. Boolean logic</a>
<ul>
<li><a href="#orgb9e1545">2.1. Booleans</a></li>
<li><a href="#org3891c36">2.2. If-else</a></li>
<li><a href="#org680e5ba">2.3. Logic gates</a></li>
<li><a href="#orgfb41ad8">2.4. Exercises and more logical gates</a></li>
</ul>
</li>
<li><a href="#org3b5bb4d">3. Numbers</a>
<ul>
<li><a href="#orgf14768a">3.1. Peano and the natural numbers</a></li>
<li><a href="#orgb717667">3.2. Addition and multiplication</a></li>
<li><a href="#orge0d82a3">3.3. The predecessor function</a></li>
<li><a href="#orgaa6a06b">3.4. Predicates on natural numbers</a></li>
</ul>
</li>
<li><a href="#orgfa8efb2">4. Combinatory logic</a>
<ul>
<li><a href="#orge80361e">4.1. SKI combinators</a></li>
<li><a href="#org5974dee">4.2. Schönfinkel combinators</a></li>
</ul>
</li>
<li><a href="#org491a8ec">5. Data structures</a>
<ul>
<li><a href="#orgd66e0e1">5.1. Pairs</a></li>
<li><a href="#orgf162806">5.2. Lists I: nil and cons</a></li>
<li><a href="#org968c870">5.3. Lists II: map and filter</a></li>
<li><a href="#org5ff6639">5.4. Binary trees</a></li>
</ul>
</li>
<li><a href="#orgac3e947">6. Recursion</a>
<ul>
<li><a href="#orgb071650">6.1. Fixpoints</a></li>
<li><a href="#orgfe49225">6.2. Evaluation</a></li>
</ul>
</li>
<li><a href="#org9e0c1d1">7. Types</a>
<ul>
<li><a href="#org5d19b13">7.1. Simply typed &lambda;-calculus</a></li>
<li><a href="#orgbf73bb5">7.2. Propositions as types</a></li>
<li><a href="#orgdd596df">7.3. Products, unions and logic</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5f13c2a" class="outline-2">
<h2 id="org5f13c2a"><span class="section-number-2">1</span> The &lambda;-calculus</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-org5bb9158" class="outline-3">
<h3 id="org5bb9158"><span class="section-number-3">1.1</span> The &lambda;-calculus</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The <a href="https://en.wikipedia.org/wiki/Lambda_calculus"><b>λ-calculus</b></a> (or <b>lambda calculus</b>) is a logical formal system
which is also a model of computation (like Turing machines). It was
introduced in the 1930s by Alonzo Church, who was looking for a formal
system able to express the notion of computability. It is
Turing-complete, that is, it has the property that every computable
function can be written on λ-calculus.
</p>

<p>
Its syntax is very simple; any expression is either:
</p>

<ul class="org-ul">
<li>a <b>variable</b>, which could have appeared before on the lambda 
abstraction;</li>

<li>a <b>lambda abstraction</b> \(\lambda x. -\), which can be interpreted 
as a function taking \(x\) as an argument and returning what is
written under \(-\), which can depend on \(x\);</li>

<li>or an <b>application</b> of two expressions \((\lambda x. M)N\) which 
applies the function \((\lambda x. M)\) over the argument \(N\).
When a function is applied, all the ocurrences of \(x\) on \(M\) will 
be substituted by \(N\). This is what is called a <b>&beta;-reduction</b>;
it captures the notion of function application.</li>
</ul>

<p>
That is, in λ-calculus any function \(f\) can be written as \((\lambda x.f(x))\), 
and it can be applied to an argument and &beta;-reduced as
</p>

<p>
\[ (\lambda x.f(x))\ y \longrightarrow f(y). \]
</p>

<p>
For example, the function that duplicates an element could be written
as \((\lambda x.\ 2 \cdot x)\), and it would be applied to \(3\) as
</p>

<p>
\[ (\lambda x.\ 2 \cdot x)\ 3 \longrightarrow 2 \cdot 3 \longrightarrow 6. \]
</p>

<p>
In this chapter, however, we will restrict ourselves to very basic
functions which do not involve arithmetic. How to define natural
numbers, addition or multiplication will be topics for future
chapters.
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=eis11j_iGMs">Lambda Calculus - Computerphile</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5aa7bc0" class="outline-3">
<h3 id="org5aa7bc0"><span class="section-number-3">1.2</span> A first example</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In Mikrokosmos, it is possible to use the backslash character as a λ
to make the input easier. If you happen to have a greek keyboard
configured, however, feel free to write "λ"! Mikrokosmos accepts both
sintaxes. For example, the nested expression \(\lambda x.(\lambda y.x)\)
can be written as <code>\x.(\y.x)</code>.
</p>

<p>
Our first example defines a very simple lambda term, the 
<b>identity function</b> \(\lambda x. x\); which is a function that takes an argument
\(x\) and returns it unchanged. Our first statement just after this
definition will be apply this function to itself. Keep in mind during
this tutorial that it is perfectly possible to apply functions to
other functions or to themselves; in fact, this is one of the core
ideas of lambda calculus.
</p>

<p>
In the previous example, the evaluation has followed this
chain of &beta;-reductions
</p>

<p>
\[ 
id\ id \longrightarrow (\lambda x.x)(\lambda x'.x') \longrightarrow (\lambda x'.x') \longrightarrow  id.
\]
</p>

<p>
Note that the specific name of a variable is irrelevant. They act only
as placeholders. A perfectly valid definition of <code>id</code> would be <code>id = \a.a</code>
or <code>id = \b.b</code>.
</p>
</div>
</div>

<div id="outline-container-org41d52eb" class="outline-3">
<h3 id="org41d52eb"><span class="section-number-3">1.3</span> Some more examples</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Function application is <b>left distributive</b> and parentheses can be
ommited when they are not necessary, that is, <code>f g h</code> must be read as
<code>(f(g))(h)</code> instead of <code>f(g(h))</code>. This goes against the usual
mathematical convention, which always writes parentheses on functions,
that is, we write
\[
f\ x\quad\text{ instead of }\quad f(x);
\]
</p>

<p>
and
\[
f\ x\ y\quad\text{ instead of }\quad (f(x))(y)\ \text{ or }\  f(x,y);
\]
</p>

<p>
but this makes it less verbose to write multiple argument functions
such as the <b>constant</b> function, which takes two arguments and
returns the first one.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
const = \x.\y.x
const id id
const id const</script>
</div>

<p>
Note that, in λ-calculus, a "function taking two arguments" and "a
function that takes an argument and returns a function taking the
second" are conceptually the same. This equivalence is called
<b><a href="https://en.wikipedia.org/wiki/Currying">currying</a></b> in honor of <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>, the logician who developed this
idea, previously discovered by Schönfinkel and Frege.
</p>

<p>
This is why we can see every function with two arguments as a function
taking only one argument and returning again a function taking the
second one. For example, the <code>(const id)</code> function is a function that
takes only one argument, discards it, and outputs <code>id</code>.
</p>

<p>
A more useful example of function taking functions as arguments is the
function <b><b>composition</b></b>, which takes two functions and returns a new
one created by applying the two sequentially. This corresponds to the
usual mathematical function composition \(f \circ g\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Comments can be inserted starting a line with the # character
# A constant function
alwaysid = const id
alwaysid id
alwaysid const

# Function composition
compose = \f.\g.\x.f (g x)
compose id id</script>
</div>
</div>
</div>

<div id="outline-container-org6d6ed4d" class="outline-3">
<h3 id="org6d6ed4d"><span class="section-number-3">1.4</span> An exercise</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>Exercise 1.1:</b> Think what should be the result of evaluating the
following expressions and then check it with the interpreter.
</p>

<ul class="org-ul">
<li><code>compose const id</code></li>
<li><code>compose id const</code></li>
<li><code>compose const const</code></li>
</ul>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>
</div>

<div id="outline-container-org8dc0986" class="outline-2">
<h2 id="org8dc0986"><span class="section-number-2">2</span> Boolean logic</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgb9e1545" class="outline-3">
<h3 id="orgb9e1545"><span class="section-number-3">2.1</span> Booleans</h3>
<div class="outline-text-3" id="text-2-1">
<p>
<a href="https://en.wikipedia.org/wiki/Boolean_algebra">Boolean logic</a> can be encoded in &lambda;-calculus. In boolean logic, we
have two elements <code>true</code> and <code>false</code>; and some logical gates such as
</p>

<ul class="org-ul">
<li>the <b>and</b> gate, which outputs true if and only if its two inputs 
are true.</li>
<li>the <b>or</b> gate, which outputs true if any of its inputs is true,
or even if <i>both</i> are true.</li>
<li>the <b>not</b> gate, which outpus true if and only if its input is
false.</li>
</ul>

<p>
For example,
</p>

<p>
\[
\mathtt{not(\ or ( true, false )\ ) = not\ true = false}.
\]
</p>

<p>
Our intuition on what means to be a truth value is that it can
distinghish between two values (<b>true</b> or <b>false</b>) or two branches on
a program <code>(if ... else ...)</code>. We are going to use this intuition to
write an encoding of boolean values based on their ability to choose
between two branches. Maybe surprisingly, this encoding will be also
useful to write the usual boolean logic gates.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Church encoding of boolean truth values
true  = \a.\b.a
false = \a.\b.b
true
false</script>
</div>

<p>
Here, a truth value is a function on two elements that chooses one of them.
</p>

<ul class="org-ul">
<li>\(\mathtt{true}\ a\ b  = a\)</li>
<li>\(\mathtt{false}\ a\ b = b\)</li>
</ul>

<p>
This is called the <b>Church encoding</b> of the booleans, as it was
firstly used by Alonzo Church. This idea of defining a type based not
on its content but on how it can be used will appear later, when we
define more complex data structures.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
true id const
false id const
true true false
false true false</script>
</div>

<p>
In particular, <code>true</code> is exactly the same lambda term as <code>const</code>. This
is a very usual phenomenon in lambda calculus, where the same function
can be interpreted differently in different contexts. Mikrokosmos
allows us to have multiple names for the same term.
</p>
</div>
</div>

<div id="outline-container-org3891c36" class="outline-3">
<h3 id="org3891c36"><span class="section-number-3">2.2</span> If-else</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The advantage of this way of encoding the boolean values is that they
can be easily used in combination with other lambda terms. In
particular, the way to encode an if-else is almost trivial: it is
already encoded on the lambda terms!
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# If true, then the id function will be returned
# if false, then the const function will be returned 
(\b. b id const) true
(\b. b id const) false</script>
</div>

<p>
If you really want to write an <code>if-else</code> function, it will be, quite
literally, the trivial one
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
ifelse = \b.b
(ifelse true) id const
(ifelse false) id const</script>
</div>
</div>
</div>

<div id="outline-container-org680e5ba" class="outline-3">
<h3 id="org680e5ba"><span class="section-number-3">2.3</span> Logic gates</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Usual operations on booleans can be defined too on this encoding and
they will be surprisingly easy if we think of booleans as functions
choosing from two terms.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# The and gate takes two booleans and returns a true if and only if 
# the two given booleans are true. 
and = \p.\q.p q p
# Checking the truth table for the "and" gate
and true true
and true false
and false true
and false false</script>
</div>

<p>
<b>Exercise 2.1:</b> Think why this definition of the `and` gate works.
<i>Hint: think what happens when the first argument is a <code>true</code>.</i>
<i>What happens if it is a <code>false</code>?</i>
</p>

<p>
The <code>or</code> gate can be defined in a similar way.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# The or gate takes two booleans and returns a true if and only if
# any of them (or both) are true
or = \p.\q.p p q
# Checking the truth table for the "or" gate
or true true
or true false
or false true
or false false</script>
</div>

<p>
And finally, the negation operator is only a way of interchanging the two truth values
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
not = \b.b false true
# Truth table for the "not" gate
not true
not false
not (and true true)</script>
</div>
</div>
</div>

<div id="outline-container-orgfb41ad8" class="outline-3">
<h3 id="orgfb41ad8"><span class="section-number-3">2.4</span> Exercises and more logical gates</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The boolean logic implication operator works also as a boolean gate, it can be defined as
</p>

<p>
\[(a \to b) \equiv (\neg a) \vee b,\]
</p>

<p>
that is, the implication is true if both are true or if the premise is false.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
implies = \a.\b.or (not a) b
implies true true
implies true false
implies false true
implies false false</script>
</div>

<p>
<b>Exercise 2.2:</b> Compute the logic table for the implication using the
 previous definition.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
<b>Exercise 2.3:</b> Compute the following logic clauses using lambda calculus
</p>

<ul class="org-ul">
<li>True or false implies false.</li>
<li>False implies that: false implies false.</li>
<li>The negation of false and the negation of true both imply true.</li>
</ul>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
<b>Exercise 2.4:</b> Define the `xor` gate as a lambda term. The `xor` of
two boolean values must return a true if and only if <b>exactly one</b> of
them are true. Check also its logic table.
<i>Hint: you may want to use the already defined `not`.</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>
</div>

<div id="outline-container-org3b5bb4d" class="outline-2">
<h2 id="org3b5bb4d"><span class="section-number-2">3</span> Numbers</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-orgf14768a" class="outline-3">
<h3 id="orgf14768a"><span class="section-number-3">3.1</span> Peano and the natural numbers</h3>
<div class="outline-text-3" id="text-3-1">
<p>
In the 19th century, <a href="https://en.wikipedia.org/wiki/Peano_axioms">Giuseppe Peano</a> gave a definition of the natural
numbers and an axiomatic theory of them based on only two contructors
</p>

<ul class="org-ul">
<li>The zero is a natural number, written as Z.</li>
<li>The successor of a natural number is a natural number, written as
S.</li>
</ul>

<p>
In those terms, the usual natural numbers will be
</p>

<p>
\[ Z,\ SZ,\ S(SZ),\ S(S(SZ)),\ \dots \]
</p>

<p>
The question is now how can we encode them on &lambda;-calculus. We do
not have the ability to write the two constructors on &lambda;-calculus,
so we will make the natural numbers depend on them. This is again the
same idea we used when we tried to encode booleans, we do not care
about the content, but about how can we use them later.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition of the natural numbers
0 = \s.\z.z
succ = \n.\s.\z.s (n s z)

# Names for the first six natural numbers
succ 0
succ (succ 0)
succ (succ (succ 0))</script>
</div>

<p>
Under this interpretation, a number <code>n</code> is really a function taking a
function <code>a</code> as an argument and applying it <code>n</code> times over the
argument <code>b</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
5
5 not true
4 not false</script>
</div>

<p>
<b>Exercise 3.1:</b> Define a function that takes a natural number and
returns true if and only if the number is even. 
<i>Hint: you may want to interpret the given number as a function.</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-orgb717667" class="outline-3">
<h3 id="orgb717667"><span class="section-number-3">3.2</span> Addition and multiplication</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The encoding of the addition and multiplication of natural numbers
will profit from the interpretation of numbers as functions. This is,
in fact, the only way we can use naturals; but we will quickly see
that this is an strenght instead of a weakness of our encoding. We are
really encoding naturals as their induction principle: we can define a
function by defining a zero and a successor.
</p>

<p>
The <code>double</code> function will only change the successor for the
composition of the successor function with itself.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
double = \n.\s.\z.n (compose s s) z
double 0
double 3
double 4</script>
</div>

<p>
<b>Exercise 3.2</b>: Define a <code>triple</code> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
We are going now to define <b>addition</b> using this same principle. It
takes a successor and a zero, computes the first number as <code>(n s z)</code>
and then uses it as a zero on the interpretation of the second one.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
plus = \m.\n.\s.\z.m s (n s z)
plus 2 1
plus 3 4
plus 0 5</script>
</div>

<p>
<b>Exercise 3.3:</b> How would you define multiplication? Keep in mind that
you can use a number as a function. Keep also in mind the previous
exercises on <code>double</code> and <code>triple</code>.  <i>Spoilers below!</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
There many possible ways of defining multiplication. Some of them can
use the repeated application of <code>plus</code> to a number; but we are going
to define <b>multiplication</b> in a way that is similar to how we defined
<code>double</code> previously. We are going to interpret the successor as the
n-fold application of successor.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
mult = \m.\n.\s.\z.m (n s) z
mult 0 3
mult 1 5
mult 3 4</script>
</div>
</div>
</div>

<div id="outline-container-orge0d82a3" class="outline-3">
<h3 id="orge0d82a3"><span class="section-number-3">3.3</span> The predecessor function</h3>
<div class="outline-text-3" id="text-3-3">
<p>
But, how to compute the predecessor of a number? We have not encoded
negative numbers, so it could be a function returning zero whenever it
tries to get the predecessor of zero. It is an insightful exercise to
try to define it by yourself, but please, do not get too obsessed with
it. The solution is certainly not easy.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
The solution is the term that follows this paragraph. You probably
expected something easier! Kleene, who was a student of Alonzo Church,
discovered for the first time how to write a predecessor on lambda
calculus while at the dentist. This discovery made Church start
thinking that every intuitively computable function could be computed
using lambda calculus, that is, that the notions of lambda-computable
function and intuitively computable function would coincide.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
pred = \n.\f.\x.n (\g.(\h.h (g f))) (\u.x) (\u.u)
pred 4
pred 1
pred 0</script>
</div>

<p>
But why does something like this even work? The main idea is to create
a function that can be applied to a pair of numbers \(n\) times and in
such a way that the first application renders \(1,0\), and any
subsequent application acts as a successor on both numbers. We finally
take only the second one. A detailed derivation of this function can
be found <a href="https://en.wikipedia.org/wiki/Church_encoding#Derivation_of_predecessor_function">here</a>.
</p>

<p>
<b>Exercise 3.4:</b> Use the predecessor function to define the <code>minus</code>
function. It should return the difference between two numbers. It
should return zero whenever the first number is smaller than the
second.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-orgaa6a06b" class="outline-3">
<h3 id="orgaa6a06b"><span class="section-number-3">3.4</span> Predicates on natural numbers</h3>
<div class="outline-text-3" id="text-3-4">
<p>
This encoding even allow us to write predicates on natural
numbers. The first predicate will be a function distinguishing a
successor from a zero. It will be user later to build more complex
ones.
</p>

<p>
It is built by appliying a <code>const false</code> function <code>n</code> times to a true
constant. Only if it is applied <code>0</code> times, it will return a true
value.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
iszero = \n.(n (const false) true)
iszero 0
iszero 2
iszero 1</script>
</div>

<p>
Using this predicate, we can build <code>eq</code> and <code>leq</code>, corresponding to \(==\) and \(\leq\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
leq = \m.\n.(iszero (minus m n))
eq  = \m.\n.(and (leq m n) (leq n m))

leq 2 3
leq 4 1
eq  5 5</script>
</div>
</div>
</div>
</div>
<div id="outline-container-orgfa8efb2" class="outline-2">
<h2 id="orgfa8efb2"><span class="section-number-2">4</span> Combinatory logic</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orge80361e" class="outline-3">
<h3 id="orge80361e"><span class="section-number-3">4.1</span> SKI combinators</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory logic</a> provides a notation for &lambda;-terms independent
from quantified variables. Every &lambda;-expression can be written in
terms of three combinators, \(S,K,I\), which are defined as
</p>

<ul class="org-ul">
<li>\(I = \lambda x.x\), the identity function.</li>
<li>\(K = \lambda x.\lambda y.x\), the constant function.</li>
<li>\(S = \lambda x.\lambda y.\lambda z. x z (y z)\), a generalized application.</li>
</ul>

<p>
The first one, the identity, can be also written as a function of \(S\) and \(K\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
I = \x.x
K = \x.\y.x
S = \x.\y.\z.(x z (y z))

S K K</script>
</div>

<p>
The interesting property of this particular set of combinators is that
every other lambda expression can be written in terms of them. We can
see how a particular lambda expression is written in SKI calculus by
turning on the <b>ski</b> mode of the interpreter.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:ski on
S
false
true
or
and</script>
</div>

<p>
<b>Exercise 4.1:</b> How are Church-encoded numerals represented with SKI
combinators? Compute the first four or five numbers and try to come up
with the general rule.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-org5974dee" class="outline-3">
<h3 id="org5974dee"><span class="section-number-3">4.2</span> Schönfinkel combinators</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Schönfinkel and Church defined different but equivalent sets of
combinators. Some of the other classical combinators are
</p>

<ul class="org-ul">
<li>function application, `C`;</li>
<li>function composition, `B`;</li>
<li>and duplication of an argument, `W`;</li>
</ul>

<p>
and they are defined as
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
C = \f.\x.\y.f y x
B = \f.\g.\x.f (g x)
W = \x.\y.(y y)

# -- You can test the combinators here
:ski on
C S K S</script>
</div>

<p>
The <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus">Y combinator</a> is related to recursion and we will discuss it on
future chapters.
</p>
</div>
</div>
</div>
<div id="outline-container-org491a8ec" class="outline-2">
<h2 id="org491a8ec"><span class="section-number-2">5</span> Data structures</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-orgd66e0e1" class="outline-3">
<h3 id="orgd66e0e1"><span class="section-number-3">5.1</span> Pairs</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Pairs are easily defined from the boolean logic. The main idea will be
that, to apply a pair to a function will be the same thing that to
apply the function to its two components.
</p>

<p>
\[ \mathtt{pair}(a,b)(f) \equiv f\ a\ b \]
</p>

<p>
With this idea, pairs and their two projections are defined as
follows.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
tuple = \x.\y.\z.z x y
first = \p.p true
second = \p.p false

# Projections
first  (tuple 2 3)
second (tuple 2 3)

# Other functions
(tuple 3 4) plus
(tuple true false) or</script>
</div>

<p>
We use <code>true</code> and <code>false</code> to select the first or the second argument
to the function; it is possible to use the same idea to apply other
functions.
</p>
</div>
</div>
<div id="outline-container-orgf162806" class="outline-3">
<h3 id="orgf162806"><span class="section-number-3">5.2</span> Lists I: nil and cons</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Data structures such as lists or binary trees can be represented using
the same principle we used to build naturals and booleans. We would
need two constructors to represent a list a <code>nil</code> signaling the end of
the list and a <code>cons</code>, joining an element to the head of the list. A
list would be something like this
</p>

<p>
\[ \mathtt{cons}\ 1\ (\mathtt{cons}\ 2\ (\mathtt{cons}\ 3\ \mathtt{nil})).\]
</p>

<p>
As we did with natural numbers, we are going to write a representation
independent from the constructors, they are going to be passed as
arguments. We need
</p>

<ul class="org-ul">
<li><code>nil</code>, a list.</li>
<li><code>cons</code>, a function taking an element (head) and a list (tail) and
returning a new list.</li>
</ul>

<p>
This interpretation makes easier to write folding functions for
lists. We can define a function on a list simply giving the
interpretation for the <code>nil</code> and a binary function as an interpretation
for the <code>const</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
# The interpretation of nil is the nil constructor
# The interpretation of (cons h t) is cons of h and the interpretation of t 
nil  = \c.\n.n
cons = \h.\t.\c.\n.(c h (t c n))</script>

# Example
cons 1 (cons 2 (cons 3 nil))

# Folds
(cons 1 (cons 2 (cons 3 nil))) plus 0
</div>

<p>
It is useful to encode this principle into a function called
<code>fold</code>. We are going to define a summation \(\Sigma\) function and a
list product \(\Pi\) function on lists.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
fold = \c.\n.\l.(l c n)
sum  = fold plus 0
prod = fold mult 1

# Examples
sum  (cons 1 (cons 3 (cons 4 nil)))
prod (cons 1 (cons 3 (cons 4 nil)))</script>
</div>

<p>
<b>Exercise 5.1:</b> Write the <code>any</code> and <code>all</code> functions. They are
functions that can be applied over lists of booleans.
</p>

<ul class="org-ul">
<li><code>all</code> returns true if the list is made up only of <i>trues</i>.</li>
<li><code>any</code> returns true if there is at least one <i>true</i> on the list.</li>
</ul>

<p>
You may want to use the <code>fold</code> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here. Uncomment the following lines
# all = 
# any =

all (cons true  (cons true nil))
any (cons false (cons true nil))
</script>
</div>
</div>
</div>
<div id="outline-container-org968c870" class="outline-3">
<h3 id="org968c870"><span class="section-number-3">5.3</span> Lists II: map and filter</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Map, filter and fold are the most famous examples of higher order
functions on lists and a common example of the power of functional
programming, which has its roots on lambda calculus.
</p>

<ul class="org-ul">
<li>The <b>map</b> function applies a function <code>f</code> to every element on a
list.</li>
<li>The <b>filter</b> function removes the elements of the list that do not
satisfy a given predicate. It "filters" the list, leaving only
elements that satisfy the predicate.</li>
</ul>

<p>
We are going to implement these functions using our previously defined
<code>fold</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Given a cons h t, we return a cons (f h) t; given a nil, we return a nil
map = \f.(fold (\h.\t.cons (f h) t) nil)

# Examples
sum               (cons 1 (cons 2 (cons 3 nil)))
sum (map succ     (cons 1 (cons 2 (cons 3 nil))))
sum (map (mult 0) (cons 1 (cons 2 (cons 3 nil))))</script>
</div>

<p>
<b>Exercise 5.3:</b> Write functions
</p>

<ul class="org-ul">
<li>doubling the value of each number on a list.</li>
<li>negating each value of a list of booleans.</li>
</ul>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here
# doublelist = 
# negate =</script>
</div>

<p>
<b>Filter</b> can be defined using a boolean to decide at each step whether
to return a list with a head or return the tail ignoring the head,
like this
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
filter = \p.(foldr (\h.\t.((p h) (cons h t) t)) nil)

# Example
length                (cons 2 (cons 3 (cons 5 nil)))
length (filter (eq 3) (cons 2 (cons 3 (cons 5 nil))))</script>
</div>

<p>
<b>Exercise 5.4:</b> Write a function that, given any list, returns a list
containing only the even numbers on the list.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here
# filterodd =</script>
</div>
</div>
</div>
<div id="outline-container-org5ff6639" class="outline-3">
<h3 id="org5ff6639"><span class="section-number-3">5.4</span> Binary trees</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Lists have been defined using two constructors and trees will be
defined using the same technique. The only difference with lists is
that the <code>cons</code> constructor is going to be replaced by a <code>node</code>
constructor, which takes two trees as arguments. That is, a binary
tree is
</p>

<ul class="org-ul">
<li>an empty tree.</li>
<li>a node, containing a label, a left subtree, and a right subtree.</li>
</ul>

<p>
Defining functions using a fold-like combinator is again very simple
due to the chosen representation. We are going to need also a variant
of the usual function acting on three arguments, the label, the right
node and the left node.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
node = \x.\l.\r.\f.\n.(f x (l f n) (r f n))

# Example on natural numbers
mytree    = node 4 (node 2 nil nil) (node 3 nil nil)
triplesum = \a.\b.\c.plus (plus a b) c
mytree triplesum 0
</script>
</div>
</div>
</div>
</div>
<div id="outline-container-orgac3e947" class="outline-2">
<h2 id="orgac3e947"><span class="section-number-2">6</span> Recursion</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgb071650" class="outline-3">
<h3 id="orgb071650"><span class="section-number-3">6.1</span> Fixpoints</h3>
<div class="outline-text-3" id="text-6-1">
<p>
We can use and define fixpoint operators in order to define recursive
functions. The problem they have is that they can not be evaluated
without arguments into a closed form, so we have to delay the
evaluation of the expression when we bind it. To do this, we use the
<code>!=</code> operator, which binds an expression to a variable <b>without</b>
simplifying it.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Do not evaluate the fix combinator alone, it enters an infinite loop!
fix != (\f.(\x.f (x x)) (\x.f (x x)))
fix (const id)</script>
</div>

<p>
This `fix` operator (which is more commonly called the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus">Y combinator</a>)
allows us to use the function we are defining on its own
definition. The function will be passed as the first argument to the
argument of fix, as <code>f = fix (\f. ...)</code>. It is important to notice
that recursive functions, even if they work, cannot be evaluated alone
without entering an infinite beta-reduction loop.
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=9T8A89jgeTI">Essentials: Functional Programming's Y Combinator - Computerphile</a></li>
</ul>

<p>
In Mikrokosmos, we need the <code>!=</code> operator when defining recursive
functions to prevent them from expanding.
</p>

<p>
Our first example is the <b>factorial</b> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
fact != fix (\f.\n.iszero n 1 (mult n (f (pred n))))
fact 3
fact 4</script>
</div>

<p>
The complexity of computing a factorial grows exponentially, and the
lambda calculus (and particularly, this encoding of natural numbers)
was not thought to be efficient. <code>fact 6</code> will surely be too much for
the interpreter.
</p>

<p>
As a last example, we are going to define <b>Fibonacci</b> numbers.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
fib != fix (\f.\n.iszero n 1 (plus (f (pred n)) (f (pred (pred n)))))

# Examples
fib 0
fib 1
fib 2
fib 3
fib 4

# Take care when defining functions using fixpoint combinators!
# Recursion can easily lead to non-terminating computations</script>
</div>
</div>
</div>
<div id="outline-container-orgfe49225" class="outline-3">
<h3 id="orgfe49225"><span class="section-number-3">6.2</span> Evaluation</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The order in which evaluation is performed is crucial to determine if
an expression will eventually terminate. Mikrokosmos evaluates every
expression from left to right, that is, the arguments of a function
are not evaluated until they are being actually used on the
function. This is not the most efficient way: if the same argument
appears twice in the body of the function, it will be evaluated twice!
but it prevent some expressions taking from entering an inifinite
loop.
</p>

<p>
For example, <code>fix</code> is a non-terminating term (it <b>diverges</b>); but if
it is used inside an <code>ifelse</code> statement, it will be not evaluated at
all.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
false fix 3
true 4 fix</script>
</div>

<p>
If <code>false 2 fix</code> is evaluated, however, Mikrokosmos will enter an
infinite loop. Normally, your browser will allow you to stop the
Javascript script and reload the page.
</p>
</div>
</div>
</div>

<div id="outline-container-org9e0c1d1" class="outline-2">
<h2 id="org9e0c1d1"><span class="section-number-2">7</span> Types</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-org5d19b13" class="outline-3">
<h3 id="org5d19b13"><span class="section-number-3">7.1</span> Simply typed &lambda;-calculus</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Until now, we have been talking about untyped lambda calculus, but we
are now going to deal with the simply-typed lambda calculus. The main
differences are that
</p>

<ul class="org-ul">
<li>every term has a type;</li>
<li>only a subset of the lambda expressions can be written in
simply-typed lambda calculus, the typable ones;</li>
<li>every term normalizes, that is, every computation finishes;</li>
<li>as a consequence, it is not Turing-complete.</li>
</ul>

<p>
The command <code>:types on</code> activates types. Types are displayed with
every lambda expression, but certain lambda expressions which cannot
be typed cannot be used anymore. The <code>fix</code> operator is an example.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on

# Some examples
id
K
fix

# Function application
plus
plus 3
plus 3 2</script>
</div>

<p>
A type is written as a set of type variables and arrows, where <code>A -&gt; B</code>
represents the type of a function between <code>A</code> and <code>B</code>. Currying
works also with types, and a multiargument function must be written as
<code>A -&gt; B -&gt; C</code>. The interpreter will always try to infer the 
<b>most general type</b>, that is, it is preferible to have <code>A -&gt; B</code> than the
particular case <code>A -&gt; C -&gt; D</code> where <code>B</code> happens to be <code>C -&gt; D</code>.
</p>
</div>
</div>

<div id="outline-container-orgbf73bb5" class="outline-3">
<h3 id="orgbf73bb5"><span class="section-number-3">7.2</span> Propositions as types</h3>
<div class="outline-text-3" id="text-7-2">
<p>
What types are inhabited? It is easy to find an expression of the type
<code>A -&gt; A</code>, but it seems that there is no expression of type <code>A -&gt; B</code>. 
We can reason that any expression of that type should be able to
transform any given input type onto any desired output type, and that
such an expression would not be possible.
</p>

<p>
The rules of lambda calculus are similar to the rules of the
intuitionistic propositional logic; this means that a type will be
inhabited if and only if the type, reading arrows as logical
implications, is a tautology of propositional logic.
</p>

<p>
The axioms of intuistic propositional logic are
</p>

<ul class="org-ul">
<li>every expression implies itself, <code>A -&gt; A</code>.</li>
<li>we can discard any assumption to arrive at a conclusion <code>A -&gt; B -&gt; A</code>.</li>
<li>an assumption can be used multiple times to arrive at intermediate
conclusions, <code>(A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</code>.</li>
</ul>

<p>
Those are precisely the types of the SKI combinators. As any lambda
expression can be written in terms of these combinators, every lambda
expression of a type is actually a <b>proof</b> of the proposition the
type represents.
</p>

<p>
We can define some logical connectives using only the implication. For
example, the negation of a proposition \(A\) would be a function taking
\(A\) and returning any given type. As we discussed earlier, this should
be impossible, so the existence of a function `T -&gt; B` where `B` is a
free variable should be a proof of the type `T` not being inhabited.
</p>

<p>
For example, we can write a proof of the <b>modus ponens</b> by presenting
an inhabitant of the type \(A \to (A \to B) \to B\), where A and B are
free type variables.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Axioms of intuitionistic propositional logic
:types on
I
K
S

# Modus ponens
\a.\b.b a</script>
</div>
</div>
</div>
<div id="outline-container-orgdd596df" class="outline-3">
<h3 id="orgdd596df"><span class="section-number-3">7.3</span> Products, unions and logic</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Mikrokosmos supports product, union, unit and void types. They
can be used with the following typed constructors
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Constructor</th>
<th scope="col" class="org-left">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>(-,-)</code></td>
<td class="org-left"><code>A → B → A × B</code></td>
</tr>

<tr>
<td class="org-left"><code>fst</code></td>
<td class="org-left"><code>(A × B) → A</code></td>
</tr>

<tr>
<td class="org-left"><code>snd</code></td>
<td class="org-left"><code>(A × B) → B</code></td>
</tr>

<tr>
<td class="org-left"><code>inl</code></td>
<td class="org-left"><code>A → A + B</code></td>
</tr>

<tr>
<td class="org-left"><code>inr</code></td>
<td class="org-left"><code>B → A + B</code></td>
</tr>

<tr>
<td class="org-left"><code>unit</code></td>
<td class="org-left"><code>⊤</code></td>
</tr>

<tr>
<td class="org-left"><code>abort</code></td>
<td class="org-left"><code>⊥ → A</code></td>
</tr>

<tr>
<td class="org-left"><code>absurd</code></td>
<td class="org-left"><code>⊥ → ⊥</code></td>
</tr>

<tr>
<td class="org-left"><code>caseof</code></td>
<td class="org-left"><code>(A + B) → (A → C) → (B → C) → C</code></td>
</tr>
</tbody>
</table>

<p>
These types complete the correspondence between intuitionistic logic and lambda calculus. A type is inhabited if and only if its proposition is provable.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Proposition</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Product type</td>
<td class="org-left"><code>A × B</code></td>
<td class="org-left"><code>A ∧ B</code></td>
<td class="org-left">Logical conjunction</td>
</tr>

<tr>
<td class="org-left">Disjoint union type</td>
<td class="org-left"><code>A + B</code></td>
<td class="org-left"><code>A ∨ B</code></td>
<td class="org-left">Logical disjunction</td>
</tr>

<tr>
<td class="org-left">Unit type</td>
<td class="org-left"><code>⊤</code></td>
<td class="org-left"><code>⊤</code></td>
<td class="org-left">True proposition</td>
</tr>

<tr>
<td class="org-left">Empty type</td>
<td class="org-left"><code>⊥</code></td>
<td class="org-left"><code>⊥</code></td>
<td class="org-left">False proposition</td>
</tr>

<tr>
<td class="org-left">Function to empty</td>
<td class="org-left"><code>A → ⊥</code></td>
<td class="org-left"><code>¬A</code></td>
<td class="org-left">Logical negation</td>
</tr>
</tbody>
</table>

<p>
The following are examples of the use of typed constructors.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
fst (2,3)
snd (2,3)
inl true
inr false
caseof (inl 3) (mult 2) (plus 1)
caseof (inr 3) (mult 2) (plus 1)
unit</script>
</div>

<p>
The characteristic difference of classical versus intuitionistic logic
is that \(A \vee \neg A\) and \(\neg \neg A \to A\) (the law of excluded
middle, LEM) are not provable on intuitionistic logic. It is not
possible to find an expression of type <code>A + (A → ⊥)</code>, 
which would correspond to \(A \vee \neg A\).
</p>

<p>
It is possible, however, to prove \(\neg \neg (A \vee \neg A)\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
notnotlem = \f.f (inr (\a.absurd (f (inl a))))
notnotlem</script>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mario Román <a href="https://github.com/M42/">(github)</a></p>
<p class="date">Created: 2017-08-29 Tue 19:10</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
