<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-09-09 Sat 16:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mikrokosmos</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Mario Román [[https://github.com/M42/][(github)]](github)" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="styles/readtheorg/js/readtheorg.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/codemirror.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/codemirror.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/addon/mode/simple.min.js"></script>
<script src="https://m42.github.io/mikrokosmos-js/codemirrormkr.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/rts.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/lib.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/out.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/runmain.js"></script>
<script language="javascript" src="https://m42.github.io/mikrokosmos-js/mikrobox.js" defer></script>
<link rel="stylesheet" href="styles/mikrocode.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Mikrokosmos
<br>
<span class="subtitle">Programming on the λ-calculus</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0419057">1. The &lambda;-calculus</a>
<ul>
<li><a href="#orga64239c">1.1. The untyped &lambda;-calculus</a></li>
<li><a href="#org2bf36a8">1.2. A first example</a></li>
<li><a href="#orgc20474c">1.3. Some more examples</a></li>
<li><a href="#org6eb0382">1.4. Exercises</a></li>
</ul>
</li>
<li><a href="#org4814622">2. Boolean logic</a>
<ul>
<li><a href="#orgec2ec74">2.1. Booleans</a></li>
<li><a href="#org3a9e8ef">2.2. If-else</a></li>
<li><a href="#orgd0f2284">2.3. Logic gates</a></li>
<li><a href="#orge9b3ab4">2.4. Exercises and more logical gates</a></li>
</ul>
</li>
<li><a href="#orge5cd8a9">3. Numbers</a>
<ul>
<li><a href="#org19da85a">3.1. Peano and the natural numbers</a></li>
<li><a href="#orge4c5b43">3.2. Addition and multiplication</a></li>
<li><a href="#orgda20ea5">3.3. The predecessor function</a></li>
<li><a href="#orgb264977">3.4. Predicates on natural numbers</a></li>
</ul>
</li>
<li><a href="#org7b8fefa">4. Combinatory logic</a>
<ul>
<li><a href="#org97d4dfb">4.1. SKI combinators</a></li>
<li><a href="#org457d4f7">4.2. Schönfinkel combinators</a></li>
</ul>
</li>
<li><a href="#orgebe377c">5. Data structures</a>
<ul>
<li><a href="#org6862d73">5.1. Tuples</a></li>
<li><a href="#orgcb25166">5.2. Lists I: nil and cons</a></li>
<li><a href="#org8517180">5.3. Lists II: map and filter</a></li>
<li><a href="#orga0914c2">5.4. Binary trees</a></li>
</ul>
</li>
<li><a href="#orgdfffe8a">6. Recursion</a>
<ul>
<li><a href="#orgbd88ad0">6.1. Fixpoints</a></li>
<li><a href="#org6afabc9">6.2. Evaluation</a></li>
</ul>
</li>
<li><a href="#orgcbf397f">7. Types</a>
<ul>
<li><a href="#org01efb8e">7.1. Simply typed &lambda;-calculus</a></li>
<li><a href="#orgf858734">7.2. Propositions as types</a></li>
<li><a href="#orga1f600f">7.3. Products, unions and logic</a></li>
<li><a href="#org7b42458">7.4. Conjunctions, disjunctions and proofs</a></li>
<li><a href="#org2a8c251">7.5. Curry-Howard</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This is a tutorial in how to program on the untyped and simply-typed
&lambda;-calculus using the <b><a href="index.html">Mikrokosmos</a></b> interpreter. It is divided
on seven chapters.
</p>

<ol class="org-ol">
<li><a href="#org0419057">The &lambda;-calculus</a>: describes the lenguage.</li>
<li><a href="#org4814622">Boolean logic</a>: implements logical gates.</li>
<li><a href="#orge5cd8a9">Numbers</a>: implements aritmetical operators and comparisons.</li>
<li><a href="#org7b8fefa">Combinatory logic</a>: describes the SKI combinators.</li>
<li><a href="#orgebe377c">Data structures</a>: implements lists and binary trees.</li>
<li><a href="#orgdfffe8a">Recursion</a>: describes fixpoint operators and implements recursion.</li>
<li><a href="#orgcbf397f">Types</a>: describes the simply-typed &lambda;-calculus and its logical interpretation.</li>
</ol>

<div id="outline-container-org0419057" class="outline-2">
<h2 id="org0419057"><span class="section-number-2">1</span> The &lambda;-calculus</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orga64239c" class="outline-3">
<h3 id="orga64239c"><span class="section-number-3">1.1</span> The untyped &lambda;-calculus</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The untyped <a href="https://en.wikipedia.org/wiki/Lambda_calculus"><b>λ-calculus</b></a> (or simply, <b>&lambda; calculus</b>) is a logical formal system
which is also a model of computation (like the <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing machines</a>, for
example). It was introduced in the 1930s by <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>, who was
looking for a formal system able to express the notion of
computability. It is <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a>, that is, it has the property
that every computable function, every function you could write in any
other programming language, can be written on the untyped λ-calculus.
</p>

<p>
Its <a href="https://en.wikipedia.org/wiki/Lambda_calculus_definition#Standard_definition">syntax</a> is very simple; any expression is either:
</p>

<ul class="org-ul">
<li>a <b>variable</b>, \(x,y,z,\dots\) which could have appeared before on
the lambda abstraction;</li>

<li>a <b>lambda abstraction</b> \(\lambda x. -\), which can be interpreted 
as a function taking \(x\) as an argument and returning what is
written under \(-\), which can depend on \(x\);</li>

<li>or an <b>application</b> of two expressions \((\lambda x. M)N\) which 
applies the function \((\lambda x. M)\) over the argument \(N\).
When a function is applied, all the ocurrences of \(x\) on \(M\) will 
be substituted by \(N\). This is what is called a <b>&beta;-reduction</b>;
it captures the notion of function application.</li>
</ul>

<p>
That is, in λ-calculus any function \(f\) can be written as \((\lambda x.f(x))\), 
and it can be applied to an argument and &beta;-reduced as
</p>

<p>
\[ (\lambda x.f(x))\ y \longrightarrow f(y). \]
</p>

<p>
For example, the function that duplicates an element could be written
as \((\lambda x.\ 2 \cdot x)\), and it would be applied to \(3\) as
</p>

<p>
\[ (\lambda x.\ 2 \cdot x)\ 3 \longrightarrow 2 \cdot 3 \longrightarrow 6. \]
</p>

<p>
In this chapter, however, we will restrict ourselves to very basic
functions which do not involve arithmetic. How to define natural
numbers, addition or multiplication will be topics for future
chapters.
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=eis11j_iGMs">Lambda Calculus - Computerphile</a></li>
</ul>

<p>
On this tutorial we will use a didactic &lambda;-calculus interpreter,
<a href="https://github.com/M42/mikrokosmos">Mikroskosmos</a>; which can be used directly from the browser. Every time
you find a Mikrokosmos code snippet like the following, you can execute
it by pressing <b>evaluate</b>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
(λx.mult 2 x) 3</script>
</div>
</div>
</div>

<div id="outline-container-org2bf36a8" class="outline-3">
<h3 id="org2bf36a8"><span class="section-number-3">1.2</span> A first example</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In Mikrokosmos, it is possible to use the backslash character as a λ
to make the input easier. If you happen to have a greek keyboard
configured, however, feel free to write "λ"! Mikrokosmos accepts both
sintaxes. For instance, the nested expression \(\lambda x.(\lambda y.x)\)
can be written as <code>\x.(\y.x)</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Our first example
id = \x.x
id id

# More examples on the identity function
id 3
id 2</script>
</div>

<p>
Our first example defines the <b>identity function</b> \(\lambda x. x\);
which is a function that takes an argument \(x\) and returns it
unchanged. Our first statement just after this definition applies this
function to itself, and the result is again the identity.  Keep in
mind during this tutorial that it is perfectly possible to apply
functions to other functions or to themselves; in fact, this is one of
the core ideas of &lambda;-calculus.
</p>

<p>
In its output, Mikrokosmos shows the evaluated term and possible names
for it. We will learn what those names mean later. In the previous
example, the evaluation of <code>id id</code> to <code>id</code> has followed this chain of
&beta;-reductions and equivalences
</p>

<p>
\[ 
id\ id \longrightarrow (\lambda x.x)(\lambda x'.x') \longrightarrow (\lambda x'.x') \longrightarrow  id.
\]
</p>

<p>
Note that the specific name of a variable is irrelevant. They act only
as placeholders. A perfectly valid definition of <code>id</code> would be <code>id = \a.a</code>
or <code>id = \b.b</code>.
</p>
</div>
</div>

<div id="outline-container-orgc20474c" class="outline-3">
<h3 id="orgc20474c"><span class="section-number-3">1.3</span> Some more examples</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Function application is <b>left distributive</b> and parentheses can be
ommited when they are not necessary, that is, <code>f g h</code> must be read as
<code>(f(g))(h)</code> instead of <code>f(g(h))</code>. This goes against the usual
mathematical convention, which always writes parentheses on functions,
that is, we write
\[
f\ x\quad\text{ instead of }\quad f(x);
\]
</p>

<p>
and
\[
f\ x\ y\quad\text{ instead of }\quad (f(x))(y)\ \text{ or }\  f(x,y);
\]
</p>

<p>
but this makes it less verbose to write multiple argument functions
such as the <b>constant</b> function, which takes two arguments and
returns the first one.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
const = \x.\y.x
const 3 4
const id id
const id const</script>
</div>

<p>
Note that, in λ-calculus, a <i>"function taking two arguments"</i> and 
<i>"a function that takes an argument and returns a function taking the second"</i>
are conceptually the same. This equivalence is called
<b><a href="https://en.wikipedia.org/wiki/Currying">currying</a></b> in honor of <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>, the logician who developed this
idea, previously discovered by Schönfinkel and Frege.
</p>

<p>
This is why we can see every function with two arguments as a function
taking only one argument and returning again a function taking the
second one. For example, the <code>discard = const id</code> function is a function that
takes only one argument, discards it, and outputs <code>id</code>. This is called
a <b>partial application</b> of a function.
</p>

<p>
A more useful example of function taking functions as arguments is the
<b>function composition</b>, which takes two functions and returns a new
one created by applying the two sequentially. This corresponds to the
usual mathematical function composition \(f \circ g\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Comments can be inserted starting a line with the # character
# A constant function
discard = const id
discard 2
discard id
discard const

# Function composition
compose = \f.\g.\x.f (g x)
compose id id</script>
</div>
</div>
</div>

<div id="outline-container-org6eb0382" class="outline-3">
<h3 id="org6eb0382"><span class="section-number-3">1.4</span> Exercises</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>Exercise 1.1:</b> Think what should be the result of evaluating the
following expressions and then check it with the interpreter.
</p>

<ul class="org-ul">
<li><code>compose const id</code></li>
<li><code>compose id const</code></li>
<li><code>compose const const</code></li>
</ul>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here
# Feel free to play with the interpreter!</script>
</div>

<p>
<b>Exercise 1.2:</b> Write
</p>

<ul class="org-ul">
<li><i>function application</i>, a function taking a function \(f\) and a term
\(x\) as arguments and returning \(f(x)\).</li>

<li><i>swapping of arguments</i>, a function that takes a function on two
arguments \(f\) and returns a \(g\) such that \(g(x,y) = g\ x\ y = f\ y\ x = f(y,x)\).</li>
</ul>

<p>
And test them.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solutions go here</script>
</div>
</div>
</div>
</div>

<div id="outline-container-org4814622" class="outline-2">
<h2 id="org4814622"><span class="section-number-2">2</span> Boolean logic</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgec2ec74" class="outline-3">
<h3 id="orgec2ec74"><span class="section-number-3">2.1</span> Booleans</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We will start our programming journey on &lambda;-calculus encoding
<a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean logic</a>. In boolean logic, we have two elements <code>true</code> and
<code>false</code>; and some logical gates such as
</p>

<ul class="org-ul">
<li>the <b>and</b> gate, which outputs true if and only if its two inputs 
are true.</li>
<li>the <b>or</b> gate, which outputs true if any of its inputs is true,
or even if <i>both</i> are true.</li>
<li>the <b>not</b> gate, which outpus true if and only if its input is
false.</li>
</ul>

<p>
For example,
</p>

<p>
\[
\mathtt{not(\ or ( true, false )\ ) = not\ true = false}.
\]
</p>

<p>
Our intuition on what means to be a truth value is that it can
distinghish between two values (<b>true</b> or <b>false</b>) or two branches on
a program <code>(if ... then ... else ...)</code>. We are going to use this intuition to
write an encoding of boolean values based on their ability to choose
between two branches. Maybe surprisingly, this encoding will be also
useful to write the usual boolean logic gates.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Church encoding of boolean truth values
true  = \a.\b.a
false = \a.\b.b
true
false</script>
</div>

<p>
Here, a truth value is a function on two elements that chooses one of them.
</p>

<ul class="org-ul">
<li>\(\mathtt{true}\ a\ b  = a\)</li>
<li>\(\mathtt{false}\ a\ b = b\)</li>
</ul>

<p>
This is called the <b>Church encoding</b> of the booleans, as it was
used by Alonzo Church for the first time. This idea of defining a type based not
on its content but on how it can be used will appear later, when we
define more complex data structures.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
true id const
false id const
true true false
false true false</script>
</div>

<p>
In particular, <code>true</code> is exactly the same lambda term as <code>const</code>. This
is a very usual phenomenon in &lambda;-calculus, where the same function
can be interpreted differently in different contexts. Mikrokosmos
allows us to have multiple names for the same term.
</p>
</div>
</div>

<div id="outline-container-org3a9e8ef" class="outline-3">
<h3 id="org3a9e8ef"><span class="section-number-3">2.2</span> If-else</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The advantage of this way of encoding the boolean values is that they
can be easily used in combination with other &lambda;-terms. In
particular, the way to encode an if-else is almost trivial: it is
already encoded on the &lambda;-terms!
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# If true, then the id function will be returned
# if false, then the const function will be returned 
(\b. b id const) true
(\b. b id const) false</script>
</div>

<p>
If you really want to write an <code>if-else</code> function, it will be, quite
literally, the trivial one
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
ifelse = \b.b
ifelse true id const
ifelse false id const</script>
</div>
</div>
</div>

<div id="outline-container-orgd0f2284" class="outline-3">
<h3 id="orgd0f2284"><span class="section-number-3">2.3</span> Logic gates</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Usual operations on booleans can be defined too on this encoding and
they will be surprisingly easy if we think of booleans as functions
choosing from two terms.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# The and gate takes two booleans and returns a true if and only if 
# the two given booleans are true. 
and = \p.\q.p q p
# Checking the truth table for the "and" gate
and true true
and true false
and false true
and false false</script>
</div>

<p>
<b>Exercise 2.1:</b> Think why this definition of the <code>and</code> gate works.
<i>Hint: think what happens when the first argument is a <code>true</code>.</i>
<i>What happens if it is a <code>false</code>?</i>
</p>

<p>
The <code>or</code> gate can be defined in a similar way.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# The or gate takes two booleans and returns a true if and only if
# any of them (or both) are true
or = \p.\q.p p q
# Checking the truth table for the "or" gate
or true true
or true false
or false true
or false false</script>
</div>

<p>
And finally, the negation operator is only a way of interchanging the two truth values
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
not = \b.b false true
# Truth table for the "not" gate
not true
not false
not (and true true)</script>
</div>
</div>
</div>

<div id="outline-container-orge9b3ab4" class="outline-3">
<h3 id="orge9b3ab4"><span class="section-number-3">2.4</span> Exercises and more logical gates</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The boolean logic implication operator works also as a boolean gate, it can be defined as
</p>

<p>
\[(a \to b) \equiv (\neg a) \vee b,\]
</p>

<p>
that is, the implication is true if both are true or if the premise is false.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
implies = \a.\b.or (not a) b</script>
</div>

<p>
<b>Exercise 2.2:</b> Compute the logic table for the implication using the
 previous definition.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
<b>Exercise 2.3:</b> Compute the following logic clauses using lambda calculus
</p>

<ul class="org-ul">
<li>\((\mathtt{true} \vee \mathtt{false})\to \mathtt{false}\).</li>
<li>\(\mathtt{false} \to (\mathtt{false} \to \mathtt{false})\)</li>
<li>\((\neg \mathtt{false} \wedge \neg \mathtt{true}) \to \mathtt{true}\)</li>
</ul>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
<b>Exercise 2.4:</b> Define the `xor` gate as a lambda term. The `xor` of
two boolean values must return a true if and only if <b>exactly one</b> of
them are true. Check also its logic table.
<i>Hint: you may want to use the already defined `not`.</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>
</div>

<div id="outline-container-orge5cd8a9" class="outline-2">
<h2 id="orge5cd8a9"><span class="section-number-2">3</span> Numbers</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-org19da85a" class="outline-3">
<h3 id="org19da85a"><span class="section-number-3">3.1</span> Peano and the natural numbers</h3>
<div class="outline-text-3" id="text-3-1">
<p>
In the 19th century, <a href="https://en.wikipedia.org/wiki/Peano_axioms">Giuseppe Peano</a> gave a definition of the natural
numbers and an axiomatic theory of them based on only two contructors
</p>

<ul class="org-ul">
<li>The zero is a natural number, written as Z.</li>
<li>The successor of a natural number is a natural number, written as
S.</li>
</ul>

<p>
In those terms, the usual natural numbers will be
</p>

<p>
\[ Z,\ SZ,\ S(SZ),\ S(S(SZ)),\ \dots \]
</p>

<p>
The question is now how can we encode them on &lambda;-calculus. We do
not have the ability to write the two constructors on &lambda;-calculus,
so we will make the natural numbers depend on them. This is again the
same idea we used when we tried to encode booleans, we do not care
about the content, but about how can we use them later.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Some natural numbers
0 = \s.\z.z
1 = \s.\z.s z
2 = \s.\z.s (s z)
3 = \s.\z.s (s (s z))

# Definition of the natural numbers
0 = \s.\z.z
succ = \n.\s.\z.s (n s z)

# Names for the first three natural numbers
succ 0
succ (succ 0)
succ (succ (succ 0))</script>
</div>

<p>
Under this interpretation, a number <code>n</code> is really a function taking a
function <code>a</code> as an argument and applying it <code>n</code> times over the
argument <code>b</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
5
5 not true
4 not false</script>
</div>

<p>
<b>Exercise 3.1:</b> Define a function that takes a natural number and
returns true if and only if the number is even. 
<i>Hint: you may want to interpret the given number as a function.</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-orge4c5b43" class="outline-3">
<h3 id="orge4c5b43"><span class="section-number-3">3.2</span> Addition and multiplication</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The encoding of the addition and multiplication of natural numbers
will profit from the interpretation of numbers as functions. We are
actually encoding naturals as their induction principle: we can define
a function by defining how it acts on zero and a successor.
</p>

<p>
The <code>double</code> function will only change the successor for the
composition of the successor function with itself.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
double = \n.\s.\z.n (compose s s) z
double 0
double 3
double 4</script>
</div>

<p>
<b>Exercise 3.2</b>: Define a <code>triple</code> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
We are going now to define <b>addition</b> using this same principle. It
takes a successor and a zero, computes the first number as <code>(n s z)</code>
and then uses it as a zero on the interpretation of the second one.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
plus = \m.\n.\s.\z.m s (n s z)
plus 2 1
plus 3 4
plus 0 5</script>
</div>

<p>
<b>Exercise 3.3:</b> How would you define multiplication? Keep in mind that
you can use a number as a function. Keep also in mind the previous
exercises on <code>double</code> and <code>triple</code>.  <i>Spoilers below!</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
There many possible ways of defining multiplication. Some of them can
use the repeated application of <code>plus</code> to a number; but we are going
to define <b>multiplication</b> in a way that is similar to how we defined
<code>double</code> previously. We are going to interpret the successor as the
n-fold application of successor.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
mult = \m.\n.\s.\z.m (n s) z
mult 0 3
mult 1 5
mult 3 4</script>
</div>
</div>
</div>

<div id="outline-container-orgda20ea5" class="outline-3">
<h3 id="orgda20ea5"><span class="section-number-3">3.3</span> The predecessor function</h3>
<div class="outline-text-3" id="text-3-3">
<p>
But, how to compute the predecessor of a number? We have not encoded
negative numbers, so it could be a function returning zero whenever it
tries to get the predecessor of zero. It is an insightful exercise to
try to define it by yourself, but please, do not get too obsessed with
it. The solution is certainly not easy.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
The solution is the term that follows this paragraph. You probably
expected something easier! Kleene, who was a student of Alonzo Church,
discovered for the first time how to write a predecessor on lambda
calculus while at the dentist. This discovery made Church start
thinking that every intuitively computable function could be computed
using lambda calculus, that is, that the notions of lambda-computable
function and intuitively computable function would coincide.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
pred = \n.\f.\x.n (\g.(\h.h (g f))) (\u.x) (\u.u)
pred 4
pred 1
pred 0</script>
</div>

<p>
But why does something like this even work? The main idea is to create
a function that can be applied to a pair of numbers \(n\) times and in
such a way that the first application renders \(1,0\), and any
subsequent application acts as a successor on both numbers. We finally
take only the second one. A detailed derivation of this function can
be found <a href="https://en.wikipedia.org/wiki/Church_encoding#Derivation_of_predecessor_function">here</a>; but we will also study it in the <b>Exercise 3.5</b>.
</p>

<p>
<b>Exercise 3.4:</b> Use the predecessor function to define the <code>minus</code>
function. It should return the difference between two numbers. It
should return zero whenever the first number is smaller than the
second.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>

<p>
<b>Exercise 3.5:</b> Let's look again at the definition of <code>pred</code>.
The core of the definition is the subexpression <code>\g.(\h.h (g f))</code>,
which we will call <code>inc f</code>. It is a sort of reversed composition.
Study what happens when we compose <code>inc f</code> with itself and reimplement
<code>pred</code> using <code>inc</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition of inc, depending on f
inc = \f.\g.\h.h (g f)

# Study step-by-step the result of these compositions
\f.compose (inc f) (inc f)
\f.compose (compose (inc f) (inc f)) (inc f)
 
# What will happen in these cases?
\f.3 (inc f)
\f.4 (inc f)
\f.5 (inc f)

# Implement pred using inc
# pred = -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-orgb264977" class="outline-3">
<h3 id="orgb264977"><span class="section-number-3">3.4</span> Predicates on natural numbers</h3>
<div class="outline-text-3" id="text-3-4">
<p>
This encoding even allows us to write predicates on natural
numbers. The first predicate will be a function distinguishing a
non-zero number from a zero. It will be used later to build more
complex ones.
</p>

<p>
It is built by applying a <code>const false</code> function <code>n</code> times to a true
constant. Only if it is applied <code>0</code> times, it will return a true
value.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
iszero = \n.(n (const false) true)
iszero 0
iszero 2
iszero 1</script>
</div>

<p>
Using this predicate, we can build <code>eq</code> and <code>leq</code>, corresponding to \(==\) and \(\leq\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
leq = \m.\n.(iszero (minus m n))
eq  = \m.\n.(and (leq m n) (leq n m))

leq 2 3
leq 4 1
eq  5 5</script>
</div>
</div>
</div>
</div>
<div id="outline-container-org7b8fefa" class="outline-2">
<h2 id="org7b8fefa"><span class="section-number-2">4</span> Combinatory logic</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-org97d4dfb" class="outline-3">
<h3 id="org97d4dfb"><span class="section-number-3">4.1</span> SKI combinators</h3>
<div class="outline-text-3" id="text-4-1">
<p>
<a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory logic</a> provides a notation for &lambda;-terms independent
from quantified variables. Every &lambda;-expression can be written in
terms of three combinators, \(S,K,I\), which are defined as
</p>

<ul class="org-ul">
<li>\(I = \lambda x.x\), the identity function.</li>
<li>\(K = \lambda x.\lambda y.x\), the constant function.</li>
<li>\(S = \lambda x.\lambda y.\lambda z. x z (y z)\), a generalized application.</li>
</ul>

<p>
The first one, the identity, can be also written as a function of \(S\) and \(K\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
I = \x.x
K = \x.\y.x
S = \x.\y.\z.(x z (y z))

S K K</script>
</div>

<p>
The interesting property of this particular set of combinators is that
every other lambda expression can be written in terms of them. We can
see how a particular lambda expression is written in SKI calculus by
turning on the <b>ski</b> mode of the interpreter.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:ski on
S
false
true
or
and</script>
</div>

<p>
<b>Exercise 4.1:</b> How are Church-encoded numerals represented with SKI
combinators? Compute the first four or five numbers and try to come up
with the general rule.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here</script>
</div>
</div>
</div>

<div id="outline-container-org457d4f7" class="outline-3">
<h3 id="org457d4f7"><span class="section-number-3">4.2</span> Schönfinkel combinators</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Schönfinkel and Church defined different but equivalent sets of
combinators. Some of the other classical combinators are
</p>

<ul class="org-ul">
<li>function application, <code>C</code>;</li>
<li>function composition, <code>B</code>;</li>
<li>and duplication of an argument, <code>W</code>;</li>
</ul>

<p>
and they are defined as
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
C = \f.\x.\y.f y x
B = \f.\g.\x.f (g x)
W = \x.\y.(y y)

# -- You can test the combinators here
:ski on
C S K S</script>
</div>

<p>
The <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus">Y combinator</a> is related to recursion and we will discuss it on
future chapters.
</p>
</div>
</div>
</div>

<div id="outline-container-orgebe377c" class="outline-2">
<h2 id="orgebe377c"><span class="section-number-2">5</span> Data structures</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-org6862d73" class="outline-3">
<h3 id="org6862d73"><span class="section-number-3">5.1</span> Tuples</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Tuples are easily defined from boolean logic. The main idea will be
that the application of tuple to a function will result on the
application of the function to its two components.
</p>

<p>
\[ \mathtt{tuple}(a,b)(f) \equiv f\ a\ b \]
</p>

<p>
With this idea, tuples and their two projections are defined as
follows.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
tuple = \x.\y.\z.z x y
first = \p.p true
second = \p.p false

# Projections
first  (tuple 2 3)
second (tuple 2 3)

# Other functions
(tuple 3 4) plus
(tuple true false) or</script>
</div>

<p>
As seen in the example, we use <code>true</code> and <code>false</code> to select the first
or the second argument to the function. It is possible to use the same
idea to apply other functions.
</p>
</div>
</div>

<div id="outline-container-orgcb25166" class="outline-3">
<h3 id="orgcb25166"><span class="section-number-3">5.2</span> Lists I: nil and cons</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Data structures such as lists or binary trees can be represented using
the same principle we used to build naturals and booleans. We would
need two constructors to represent a list a <code>nil</code> signaling the end of
the list and a <code>cons</code>, joining an element to the head of the list. A
list would be something like this
</p>

<p>
\[ \mathtt{cons}\ 1\ (\mathtt{cons}\ 2\ (\mathtt{cons}\ 3\ \mathtt{nil})).\]
</p>

<p>
As we did with natural numbers, we are going to write a representation
independent from the constructors, they are going to be passed as
arguments. We need
</p>

<ul class="org-ul">
<li><code>nil</code>, a list.</li>
<li><code>cons</code>, a function taking an element (head) and a list (tail) and
returning a new list.</li>
</ul>

<p>
This interpretation makes easier to write folding functions for
lists. We can define a function on a list simply giving the
interpretation for the <code>nil</code> and a binary function as an interpretation
for the <code>const</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
# The interpretation of nil is the nil constructor
# The interpretation of (cons h t) is cons of h and the interpretation of t 
nil  = \c.\n.n
cons = \h.\t.\c.\n.(c h (t c n))

# Example
cons 1 (cons 2 (cons 3 nil))

# Folds
(cons 1 (cons 2 (cons 3 nil))) plus 0</script>
</div>

<p>
It is useful to encode this principle into a function called
<code>fold</code>. We are going to define a summation \(\Sigma\) function and a
list product \(\Pi\) function on lists.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
fold = \c.\n.\l.(l c n)
sum  = fold plus 0
prod = fold mult 1

# Examples
sum  (cons 1 (cons 3 (cons 4 nil)))
prod (cons 1 (cons 3 (cons 4 nil)))</script>
</div>

<p>
<b>Exercise 5.1:</b> Write the <code>any</code> and <code>all</code> functions. They are
functions that can be applied over lists of booleans.
</p>

<ul class="org-ul">
<li><code>all</code> returns true if the list is made up only of <i>trues</i>.</li>
<li><code>any</code> returns true if there is at least one <i>true</i> on the list.</li>
</ul>

<p>
You may want to use the <code>fold</code> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here. Uncomment the following lines
# all = 
# any =

all (cons true  (cons true nil))
any (cons false (cons true nil))
</script>
</div>
</div>
</div>
<div id="outline-container-org8517180" class="outline-3">
<h3 id="org8517180"><span class="section-number-3">5.3</span> Lists II: map and filter</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Map, filter and fold are the most famous examples of higher order
functions on lists and a common example of the power of functional
programming, which has its roots on lambda calculus.
</p>

<ul class="org-ul">
<li>The <b>map</b> function applies a function <code>f</code> to every element on a
list.</li>
<li>The <b>filter</b> function removes the elements of the list that do not
satisfy a given predicate. It "filters" the list, leaving only
elements that satisfy the predicate.</li>
</ul>

<p>
We are going to implement these functions using our previously defined
<code>fold</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Given a cons h t, we return a cons (f h) t; given a nil, we return a nil
map = \f.(fold (\h.\t.cons (f h) t) nil)

# Examples
sum               (cons 1 (cons 2 (cons 3 nil)))
sum (map succ     (cons 1 (cons 2 (cons 3 nil))))
sum (map (mult 0) (cons 1 (cons 2 (cons 3 nil))))</script>
</div>

<p>
<b>Exercise 5.3:</b> Write functions
</p>

<ul class="org-ul">
<li>doubling the value of each number on a list.</li>
<li>negating each value of a list of booleans.</li>
</ul>

<p>
<i>Hint: you don't need to use lambda abstractions on these</i>
<i>definitions.</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here
# doublelist =
# negate =</script>
</div>

<p>
<b>Filter</b> can be defined using a boolean to decide at each step whether
to return a list with a head or return the tail ignoring the head,
like this
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
filter = \p.(foldr (\h.\t.((p h) (cons h t) t)) nil)

# Example
length                (cons 2 (cons 3 (cons 5 nil)))
length (filter (eq 3) (cons 2 (cons 3 (cons 5 nil))))</script>
</div>

<p>
<b>Exercise 5.4:</b> Write a function that, given any list, returns a list
containing only the even numbers on the list.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# -- Your solution goes here
# filterodd =</script>
</div>
</div>
</div>
<div id="outline-container-orga0914c2" class="outline-3">
<h3 id="orga0914c2"><span class="section-number-3">5.4</span> Binary trees</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Lists have been defined using two constructors and trees will be
defined using the same technique. The only difference with lists is
that the <code>cons</code> constructor is going to be replaced by a <code>node</code>
constructor, which takes two trees as arguments. That is, a binary
tree is
</p>

<ul class="org-ul">
<li>an empty tree.</li>
<li>a node, containing a label, a left subtree, and a right subtree.</li>
</ul>

<p>
Defining functions using a fold-like combinator is again very simple
due to the chosen representation. We are going to need also a variant
of the usual function acting on three arguments, the label, the right
node and the left node.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
node = \x.\l.\r.\f.\n.(f x (l f n) (r f n))

# Example on natural numbers
mytree    = node 4 (node 2 nil nil) (node 3 nil nil)
triplesum = \a.\b.\c.plus (plus a b) c
mytree triplesum 0</script>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdfffe8a" class="outline-2">
<h2 id="orgdfffe8a"><span class="section-number-2">6</span> Recursion</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgbd88ad0" class="outline-3">
<h3 id="orgbd88ad0"><span class="section-number-3">6.1</span> Fixpoints</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A fixpoint combinator is a higher-order function that, given
a function \(f\), solves the equation
</p>

<p>
\[
x = f\ x
\]
</p>

<p>
for \(x\), meaning that, if \(\mathtt{fix}\ f\) is the fixpoint of \(f\), the following
sequence of equations holds
</p>

<p>
\[
\mathtt{fix}\ f =
f (\mathtt{fix}\ f) =
f ( f (\mathtt{fix}\ f)) =
f ( f ( f (\mathtt{fix}\ f))) =
\dots
\]
</p>

<p>
The first surprising fact is that such a combinator actually exists.
In the following example, we define the <code>fix</code> combinator; which we
will use later to define recursive functions. The problem it has is
that it cannot be evaluated without arguments into a closed form, so
we have to delay the evaluation of the expression when we bind it. To
do this, we use the Mikrokosmos <code>!=</code> operator, which binds an
expression to a variable <b>without</b> simplifying it first.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Do not evaluate the fix combinator alone, it enters an infinite loop!
fix != (\f.(\x.f (x x)) (\x.f (x x)))
fix (const id)</script>
</div>

<p>
This `fix` operator (which is more commonly called the <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus">Y combinator</a>)
allows us to use the function we are defining on its own
definition. The function will be passed as the first argument to the
argument of fix, as <code>f = fix (\f. ...)</code>. It is important to notice
that recursive functions, even if they work, cannot be evaluated alone
without entering an infinite beta-reduction loop.
</p>

<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=9T8A89jgeTI">Essentials: Functional Programming's Y Combinator - Computerphile</a></li>
</ul>

<p>
In Mikrokosmos, we need the <code>!=</code> operator when defining recursive
functions to prevent them from expanding.
</p>

<p>
Our first example is the <b>factorial</b> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
fact != fix (\f.\n.iszero n 1 (mult n (f (pred n))))
fact 3
fact 4</script>
</div>

<p>
The complexity of computing a factorial grows exponentially, and the
lambda calculus (and particularly, this encoding of natural numbers)
was not thought to be efficient. <code>fact 6</code> will surely be too much for
the interpreter.
</p>

<p>
As a last example, we are going to define <b>Fibonacci</b> numbers.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Definition
fib != fix (\f.\n.iszero n 1 (plus (f (pred n)) (f (pred (pred n)))))

# Examples
fib 0
fib 1
fib 2
fib 3
fib 4

# Take care when defining functions using fixpoint combinators!
# Recursion can easily lead to non-terminating computations</script>
</div>
</div>
</div>
<div id="outline-container-org6afabc9" class="outline-3">
<h3 id="org6afabc9"><span class="section-number-3">6.2</span> Evaluation</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The order in which evaluation is performed is crucial to determine if
an expression will eventually terminate. Mikrokosmos evaluates every
expression from left to right, that is, the arguments of a function
are not evaluated until they are being actually used on the
function. This is not the most efficient way: if the same argument
appears twice in the body of the function, it will be evaluated twice!
but it prevent some expressions taking from entering an inifinite
loop.
</p>

<p>
For instance, <code>fix</code> is a non-terminating term (it <b>diverges</b>); but if
it is used inside an <code>ifelse</code> statement, it will be not evaluated at
all.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
false fix 3
true 4 fix</script>
</div>

<p>
If <code>false 2 fix</code> is evaluated, however, Mikrokosmos will enter an
infinite loop. Normally, your browser will allow you to stop the
Javascript script and reload the page.
</p>

<p>
Other examples of Mikrokosmos dealing with non terminating functions
include infinite lists as in the following examples, where we take 
the first term of an infinite list without having to evaluate it
completely or compare an infinite number arising as the fix point
of the successor function with a finite number.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Head of an infinite list of zeroes
head = fold const false
head (fix (cons 0))

# Compare infinity with other numbers
infinity != fix succ
leq infinity 6</script>
</div>
</div>
</div>
</div>

<div id="outline-container-orgcbf397f" class="outline-2">
<h2 id="orgcbf397f"><span class="section-number-2">7</span> Types</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-org01efb8e" class="outline-3">
<h3 id="org01efb8e"><span class="section-number-3">7.1</span> Simply typed &lambda;-calculus</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Until now, we have been talking about untyped lambda calculus, but we
are now going to deal with the simply-typed lambda calculus. The main
differences are that
</p>

<ul class="org-ul">
<li>every term has a type;</li>
<li>only a subset of the lambda expressions can be written in
simply-typed lambda calculus, the typable ones;</li>
<li>every term normalizes, that is, every computation finishes;</li>
<li>as a consequence, it is not Turing-complete.</li>
</ul>

<p>
The command <code>:types on</code> activates types. Types are displayed with
every lambda expression, but certain lambda expressions which cannot
be typed cannot be used anymore. The <code>fix</code> operator is an example.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on

# Some examples
id
K
fix

# Function application
plus
plus 3
plus 3 2</script>
</div>

<p>
A type is written as a set of type variables and arrows, where <code>A -&gt; B</code>
represents the type of a function between <code>A</code> and <code>B</code>. Currying
works also with types, and a multiargument function must be written as
<code>A -&gt; B -&gt; C</code>. The interpreter will always try to infer the 
<b>most general type</b>, that is, it is preferible to have <code>A -&gt; B</code> than the
particular case <code>A -&gt; C -&gt; D</code> where <code>B</code> happens to be <code>C -&gt; D</code>.
</p>

<p>
<b>Exercise 7.1:</b> The library <code>and</code> function is not typeable. Think why and
write a similar typeable <code>and</code> function.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Our previous 'and' function ...
:types off
and

# ... is not typeable
:types on
and

# -- Your solution goes here
# and2 =

and2
and2 true true
and2 true false
and2 false true
and2 false false</script>
</div>
</div>
</div>

<div id="outline-container-orgf858734" class="outline-3">
<h3 id="orgf858734"><span class="section-number-3">7.2</span> Propositions as types</h3>
<div class="outline-text-3" id="text-7-2">
<p>
What types are inhabited? It is easy to find an expression of the type
<code>A -&gt; A</code>, but it seems that there is no expression of type <code>A -&gt; B</code>. 
We can reason that any expression of that type should be able to
transform any given input type onto any desired output type, and that
such an expression would not be possible.
</p>

<p>
The rules of lambda calculus are similar to the rules of the
intuitionistic propositional logic; this means that a type will be
inhabited if and only if the type, reading arrows as logical
implications, is a tautology of propositional logic.
That is, the axioms of intuistic propositional logic are
</p>

<ul class="org-ul">
<li>every expression implies itself, <code>A -&gt; A</code>.</li>
<li>we can discard any assumption to arrive at a conclusion <code>A -&gt; B -&gt; A</code>.</li>
<li>an assumption can be used multiple times to arrive at intermediate
conclusions, <code>(A -&gt; B -&gt; C) -&gt; (A -&gt; B) -&gt; A -&gt; C</code>.</li>
</ul>

<p>
And these are precisely the types of the SKI combinators. As any lambda
expression can be written in terms of these combinators, every lambda
expression of a type is actually a <b>proof</b> of the proposition the
type represents.
</p>

<p>
We can define some logical connectives using only the implication. For
example, the negation of a proposition \(A\) would be a function taking
\(A\) and returning any given type. As we discussed earlier, this should
be impossible, so the existence of a function <code>T -&gt; B</code> where <code>B</code> is a
free variable should be a proof of the type <code>T</code> not being inhabited.
</p>

<p>
For example, we can write a proof of the <b>modus ponens</b> by presenting
an inhabitant of the type \(A \to (A \to B) \to B\), where A and B are
free type variables.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
# Axioms of intuitionistic propositional logic
:types on
I
K
S

# Modus ponens
\a.\b.b a</script>
</div>
</div>
</div>

<div id="outline-container-orga1f600f" class="outline-3">
<h3 id="orga1f600f"><span class="section-number-3">7.3</span> Products, unions and logic</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Mikrokosmos supports <b>product</b>, <b>union</b>, <b>unit</b> and <b>void</b> types.
</p>

<ul class="org-ul">
<li>The <i>product</i> type <code>A × B</code> is the type of the pairs of elements
where the first one is of type <code>A</code> and the second one is of type <code>B</code>.</li>

<li>The <i>union</i> type <code>A + B</code> is a type that can contain an element of
type <code>A</code> or an element of type <code>B</code>. It is a labeled disjoint union
of the two types.</li>

<li>The <i>unit</i> type <code>⊤</code> has only one element, called <code>unit</code> or <code>★</code>.</li>

<li>The <i>void</i> type <code>⊥</code> has no elements. Its utility will be discussed
later.</li>
</ul>

<p>
They can be used with the following typed constructors
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Constructor</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>(-,-)</code></td>
<td class="org-left"><code>A → B → A × B</code></td>
<td class="org-left">Pairs</td>
</tr>

<tr>
<td class="org-left"><code>fst</code></td>
<td class="org-left"><code>(A × B) → A</code></td>
<td class="org-left">First projection</td>
</tr>

<tr>
<td class="org-left"><code>snd</code></td>
<td class="org-left"><code>(A × B) → B</code></td>
<td class="org-left">Second projection</td>
</tr>

<tr>
<td class="org-left"><code>inl</code></td>
<td class="org-left"><code>A → A + B</code></td>
<td class="org-left">First inclusion</td>
</tr>

<tr>
<td class="org-left"><code>inr</code></td>
<td class="org-left"><code>B → A + B</code></td>
<td class="org-left">Second inclusion</td>
</tr>

<tr>
<td class="org-left"><code>caseof</code></td>
<td class="org-left"><code>(A + B) → (A → C) → (B → C) → C</code></td>
<td class="org-left">Case analysis</td>
</tr>

<tr>
<td class="org-left"><code>unit</code></td>
<td class="org-left"><code>⊤</code></td>
<td class="org-left">Unit element</td>
</tr>

<tr>
<td class="org-left"><code>abort</code></td>
<td class="org-left"><code>⊥ → A</code></td>
<td class="org-left">Empty function</td>
</tr>

<tr>
<td class="org-left"><code>absurd</code></td>
<td class="org-left"><code>⊥ → ⊥</code></td>
<td class="org-left">Empty identity</td>
</tr>
</tbody>
</table>


<p>
The following are examples of the use of typed constructors.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
fst (2,3)
snd (2,3)
inl true
inr false
caseof (inl 3) (mult 2) (plus 1)
caseof (inr 3) (mult 2) (plus 1)
unit</script>
</div>

<p>
As an example, we could use the type <code>⊤ + ⊤</code> to write a new version
of the booleans. This new version will use <code>caseof</code> as its <code>ifelse</code>.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
ttrue = inl unit
tfalse = inr unit
tnot = \b.caseof b inr inl
tand = \a.\b.caseof a (\t.b) inr

tnot ttrue
tnot tfalse
tand ttrue ttrue
tand ttrue tfalse
tand tfalse ttrue
tand tfalse tfalse</script>
</div>
</div>
</div>

<div id="outline-container-org7b42458" class="outline-3">
<h3 id="org7b42458"><span class="section-number-3">7.4</span> Conjunctions, disjunctions and proofs</h3>
<div class="outline-text-3" id="text-7-4">
<p>
These types complete the correspondence between intuitionistic logic
and lambda calculus. A type is inhabited if and only if its
proposition is provable.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Type</th>
<th scope="col" class="org-left">Proposition</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Product type</td>
<td class="org-left"><code>A × B</code></td>
<td class="org-left"><code>A ∧ B</code></td>
<td class="org-left">Logical conjunction</td>
</tr>

<tr>
<td class="org-left">Disjoint union type</td>
<td class="org-left"><code>A + B</code></td>
<td class="org-left"><code>A ∨ B</code></td>
<td class="org-left">Logical disjunction</td>
</tr>

<tr>
<td class="org-left">Unit type</td>
<td class="org-left"><code>⊤</code></td>
<td class="org-left"><code>⊤</code></td>
<td class="org-left">True proposition</td>
</tr>

<tr>
<td class="org-left">Empty type</td>
<td class="org-left"><code>⊥</code></td>
<td class="org-left"><code>⊥</code></td>
<td class="org-left">False proposition</td>
</tr>

<tr>
<td class="org-left">Function to empty</td>
<td class="org-left"><code>A → ⊥</code></td>
<td class="org-left"><code>¬A</code></td>
<td class="org-left">Logical negation</td>
</tr>
</tbody>
</table>

<p>
Following this correspondence, we are now able to write more complex
proofs on intuitionistic logic. For example, the following is a proof
of the trivial fact that
</p>

<p>
\[
A \wedge B \to B \wedge A;
\]
</p>

<p>
and, at the same time, it is a function swapping the two terms of a
pair.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
swap = \m.(snd m,fst m)
swap</script>
</div>

<p>
We had defined the negation of a type as a function from that type
to the empty type. This makes sense, only if the type is not inhabited
it is possible to write an empty function. The <code>abort</code> function is
useful if we want to use the <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">principle of explosion</a>, that is, from
falsity, everything follows. As an example, we will prove
</p>

<p>
\[
A \wedge \neg A \to B
\]
</p>

<p>
and one of the deMorgan laws
</p>

<p>
\[
\neg (A \vee B) \to \neg A \wedge \neg B
\]
</p>

<p>
as the following terms. 
<i>Note the use of <code>abort</code> and <code>absurd</code> as <code>□</code> and <code>■</code>!</i>
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
\m.abort (snd m (fst m))
\f.(\a.absurd (f (inl a)), \b.absurd (f (inr b)))</script>
</div>

<p>
The characteristic difference of classical versus intuitionistic logic
is that \(A \vee \neg A\) and \(\neg \neg A \to A\) (the law of excluded
middle, LEM) are not provable on intuitionistic logic. It is not
possible to find an expression of type <code>A + (A → ⊥)</code>, 
which would correspond to \(A \vee \neg A\).
</p>

<p>
It is possible, however, to prove \(\neg \neg (A \vee \neg A)\).
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
notnotlem = \f.f (inr (\a.absurd (f (inl a))))
notnotlem</script>
</div>

<p>
Now that we are writing proofs, it is a good time to introduce a new
feature of the interpreter. Mikrokosmos can show you the derivation
tree of any of your proofs with <code>@@</code>. For example, we will prove
that
</p>

<p>
\[
A \vee B \to B \vee A
\]
</p>

<p>
as
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
:types on
# Our proof is of type (A + B) → B + A
\m.caseof m inr inl

# And we can show a derivation tree of it as
@@ \m.caseof m inr inl

# A simpler example is the identity
@@ \x.x</script>
</div>
</div>
</div>

<div id="outline-container-org2a8c251" class="outline-3">
<h3 id="org2a8c251"><span class="section-number-3">7.5</span> Curry-Howard</h3>
<div class="outline-text-3" id="text-7-5">
<p>
The Curry-Howard isomorphism not only states the correspondence
between types and propositions and between terms and proofs; but
a full isomorphism with respect to term evaluation and proof
simplification. That is, if a term corresponds to a proof, the
fully evaluated term corresponds to a fully simplified proof.
</p>

<p>
Every simply typed &lambda;-calculus term can be understood as a
derivation tree of the term it is proving. Mikrokosmos allows the user
to check the derivation tree of a given &lambda;-term using <code>@</code>.  And
it can also simplify the derivation using <code>@@</code>, as we did before. We
will use our previously defined function/proof <code>swap</code> as an example.
</p>

<div class="mikrojs-console">
<script type="text/mikrokosmos">
@ \m.(snd m,fst m)
@@ \m.(snd m,fst m)</script>
</div>

<p>
In the first case, the function is not fully simplified, and a more
complex derivation tree arises from it. The simplification of the
term corresponds directly to a simplification of the derivation tree.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Mario Román <a href="https://github.com/M42/">(github)</a></p>
<p class="date">Created: 2017-09-09 Sat 16:59</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
